MalmoLowData
December 4, 2018
1 Setting up variables
In [10]: # Libraries for manipulating the data
import MathEngine as ME
import numpy as np
#import matplotlib.pyplot as plt
#import scipy as sp
import IPython
from numpy import amax
from numpy import amin
from numpy import average
import sys
import time
# Data source
deviceSerial = ’W020000000073041’
inSensor = ’14620’
inChannel = ’ch2’
SampleRateType = ’hertz’
SampleRate = 128
outChannel = ’TestOut’
outChannel5 = ’LowDataOutRMS’
outChannel6 = ’LowDataMixed’
#Using Microseconds or Nano
minutesMicro = 60*1000*1000*1000;
schedRunTime = 2000
microNow = int(round(time.time() * 1000))*1000*1000
microPast = microNow-schedRunTime*minutesMicro
print microNow
print microPast
#StartT = 1541100734497172000
#EndT = 1541100736603645000
StartT = microPast
EndT = microNow
time = time.asctime()
1
day = time[:3]
hour = float(time[11:13])+1 #To gmt+1
minutes = float(time[14:16])
time = hour + (minutes*.01)
print(time)
print day
print hour
print minutes
#StartT=1541100260835151000
runOnlyWeekdays = True
runOnlyCertainTime = True
runTimeStart = 07.00
runTimeEnd = 17.30
if(runOnlyWeekdays):
print "Run only on weekdays"
if(runOnlyCertainTime):
print "Run only on certain time"
if((time < runTimeStart) | (time > runTimeEnd) ):
print "Not runtime, quitting..."
if((day == "Sun") | (day == "Sat") ):
print "Not weekday, quitting..."
1543957009963000000
1543837009963000000
21.56
Tue
21.0
56.0
Run only on weekdays
Run only on certain time
Not runtime, quitting...
In [11]: repo = TimeSeriesRepo(deviceSerial)
allSeriesTest = repo.getAllTimeSeries(inSensor, inChannel)[0]
StartT = allSeriesTest.getEndTimeStamp()
print StartT
try:
outSeries5 = repo.getAllTimeSeries( inSensor, outChannel5, SampleRate, SampleRateType )[0]
print "asd"
StartT = outSeries5.getEndTimeStamp()
except:
print ’Except entered’
allSeries = repo.getAllTimeSeries( ’14620’, ’ch2’, startTime=StartT, endTime=EndT )[0]
1543931899742187500
asd
2 Starting the program
In [12]: data = np.array(allSeries.getData())
timeStamps = np.array(allSeries.getTimeStamps())
2
print len(data)
print len(timeStamps)
sampleRate = SampleRate
if(len(data)<1):
print ’no new values’
sys.exit(’quit’)
try:
outSeries5 = repo.createTimeSeries( inSensor, outChannel5, SampleRate, SampleRateType )
# outSeries6 = repo.createTimeSeries( inSensor, outChannel6, SampleRate, SampleRateType )
oldValues=False
except:
print ’Series already exist, updating...’
outSeries5 = repo.getAllTimeSeries( inSensor, outChannel5, SampleRate, SampleRateType )[0]
# outSeries6 = repo.getAllTimeSeries( inSensor, outChannel6, SampleRate, SampleRateType )[0]
oldValues=True
0
0
no new values
An exception has occurred, use %tb to see the full traceback.
SystemExit: quit
To exit: use ’exit’, ’quit’, or Ctrl-D.
In [6]: #deltaTimeStamps = 0
#outSeriesLength = 0
#if oldValues == True:
# print "Old values found"
# timeStampsLength = len(timeStamps)
# outSeriesLength = len(allSeries.getTimeStamps())
# print timeStampsLength, outSeriesLength
# deltaTimeStamps=timeStampsLength-outSeriesLength
# print "DeltatimeStamps:", deltaTimeStamps
#else:
# print "No old values"
In [7]: #Fix new values
In [ ]:
In [ ]:
3 Simple data plotting
In [ ]:
In [ ]:
3
4 Making the integration
In [13]: #acceleration = data[outSeriesLength :]
acceleration = data
velocity=[0]
velocity2ndMethod=[0]
velocityEnlarge=[0]
velocityRMS=[0]
velocityRMSBackwards=[0]
velocityMixed=[0]
#time is based on samplerate
time = 1/float(sampleRate)
lastVel=0
lastAcc=0
i=0
maxIteration = len(acceleration)
print ’accLen’, maxIteration
print len(velocity)
scaleValue=10*1000
for acc in acceleration:
i=i+1
if i < maxIteration:
deltaAcc= acc-lastAcc
vel=acc*time+deltaAcc*time/2
velocity.append((lastVel+vel)*scaleValue)
velocityRMSBackwards.append((lastVel+vel)*math.sqrt(2)*scaleValue)
velocityRMS.append(((lastVel+vel)/math.sqrt(2))*scaleValue)
velocity2ndMethod.append((lastAcc+acc)*scaleValue*time/2)
velocityEnlarge.append(lastVel*100000+vel*100000)
velocityMixed.append(((lastVel+vel)*scaleValue+(lastAcc+acc)*scaleValue*time/2)/2)
lastAcc = acc
lastVel = vel
#Making mm look like m
print ’vellength:’, len(velocity), amax(velocity), amin(velocity)
print ’vellengthMethod2:’, len(velocity2ndMethod), amax(velocity2ndMethod), amin(velocity2ndMethod)
print ’vellengthEnlarge:’, len(velocityEnlarge), amax(velocityEnlarge), amin(velocityEnlarge)
print ’vellengthRMS:’, len(velocityRMS), amax(velocityRMS), amin(velocityRMS)
print ’vellengthRMSBackwards:’, len(velocityRMSBackwards), amax(velocityRMSBackwards), amin(velocityRMSBackwards)
#print amax(acceleration)
#print len(acceleration)
print "Integration done!"
accLen 0
1
vellength: 1 0 0
vellengthMethod2: 1 0 0
vellengthEnlarge: 1 0 0
4
vellengthRMS: 1 0 0
vellengthRMSBackwards: 1 0 0
Integration done!
5 Peakvalue and sms
In [14]: threshold = 1
peakValues = [amax(velocityRMS), abs(amin(velocityRMS))]
maxIndex = velocityRMS.index(amax(velocityRMS))
minIndex = velocityRMS.index(amin(velocityRMS))
timeValues = [timeStamps[maxIndex], timeStamps[minIndex]]
maxValue = amax(peakValues)
minOrMax = peakValues.index(maxValue)
valAndTimeTuples = zip(timeValues, peakValues)
print "maxIndex: ", maxIndex, "minIndex:", minIndex
print minOrMax
print velocityRMS[maxIndex]
print peakValues
print maxValue
print timeValues
---------------------------------------------------------------------------
IndexError Traceback (most recent call last)
<ipython-input-14-5199c89f3387> in <module>()
3 maxIndex = velocityRMS.index(amax(velocityRMS))
4 minIndex = velocityRMS.index(amin(velocityRMS))
----> 5 timeValues = [timeStamps[maxIndex], timeStamps[minIndex]]
6
7
IndexError: index 0 is out of bounds for axis 0 with size 0
In [15]: if maxValue >= threshold:
sms = True
print "Threshold exceeded sending sms"
else:
sms = False
print "peakValue under threshold limit"
---------------------------------------------------------------------------
NameError Traceback (most recent call last)
5
<ipython-input-15-b7bd99a70677> in <module>()
----> 1 if maxValue >= threshold:
2 sms = True
3 print "Threshold exceeded sending sms"
4 else:
5 sms = False
NameError: name ’maxValue’ is not defined
In [ ]: sendJohan = True
sendMattias = True
if sms:
import json
import requests
numberJohan = "46738345809"
numberMattias = "46703044710"
URL = ’https://api.budgetsms.net/sendsms/’
URLtest = ’https://api.budgetsms.net/testsms/’
message = "Hej! Vi har uppm¨att vibrationerna till: " + str(maxValue) + ", vilket ¨overskrider den satta niv˚an p˚a:" + str(threshold)
if sendJohan:
data = {
"username": "j_ericsson_85@hotmai",
"userid": "16203",
"handle": "ed7864be91844399af3d9478e1109946",
"msg": message,
"from": "OmgivningAB",
"to": phonenumber
}
jdata = json.dumps(data)
r = requests.get(URL, data)
print r
print r.text
print r.content
print r.status_code
if sendMattias:
data = {
"username": "j_ericsson_85@hotmai",
"userid": "16203",
"handle": "ed7864be91844399af3d9478e1109946",
"msg": message,
"from": "OmgivningAB",
"to": phonenumber
}
jdata = json.dumps(data)
r = requests.get(URL, data)
print r
print r.text
print r.content
6
In [ ]:
In [ ]:
In [ ]:
6 Pushing data to channel
In [8]: #repo = TimeSeriesRepo(deviceSerial)
#if oldValues==1:
# time=timeStamps[outSeriesLength :]#series512hz.getTimeStamps()
#else:
# time=timeStamps
#if oldValues==1:
# time=timeStamps[outSeriesLength :]#series512hz.getTimeStamps()
#else:
# time=timeStamps
time=timeStamps
print len(time), len(velocityEnlarge)
#outData = zip(time, velocity)
#outData2 = zip(time, velocityEnlarge)
#outData3 = zip(time, velocity2ndMethod)
#outData4 = zip(time, velocityRMSBackwards)
outData5 = zip(time, velocityRMS)
outData6 = zip(time, velocityMixed)
print ’ok?...’
outSeries5.push(outData5)
#outSeries6.push(outData6)
print ’pushed’
outSeries5.save()
outSeries5.tagAsMathengine()
#outSeries6.save()
#outSeries6.tagAsMathengine()
print ’ok!’
#succes=0
#i=1
#while succes<1:
# try:
# print ’ok?...’
# outSeries5.push(outData5)
# outSeries6.push(outData6)
# print ’pushed’
# outSeries5.save()
# outSeries5.tagAsMathengine()
# outSeries6.save()
# outSeries6.tagAsMathengine()
# print ’ok!’
# succes=1
# except:
7
# print "except entered ", i,"time"
# outData5 = zip(time[i :], velocityRMS[i :])
# outData6 = zip(time[i :], velocityMixed[i :])
# print len(time[i :])
# i = i+1
128860 128860
ok?...
pushed
ok!
In [ ]: #outSeries4 = repo.getAllTimeSeries( inSensor, outChannel4, SampleRate, SampleRateType )[0]
#outSeries4.tagAsMathengine()
7 #Making Email
In [ ]:
In [ ]:
8